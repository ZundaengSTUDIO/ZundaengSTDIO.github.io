# -*- coding: utf-8 -*-
"""SWIFT 정리.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1KAfQ2QzT_tyKrgq0BdKNfLBbK2Sseh9n

#0 이름짓기 규칙

SWIFT 문법은 이름을 지을 때 낙타등처럼 대문자와 소문자로 연결되어있다.  
###Lower Camel Case
> fuction, method, variable, constant
>>someVariableName

###Upper Camel Case
>type(class, struct, enum, extension...)
>>Person, Point, Week

#1 상수, 변수

`let 이름: 타입 = 값`  
`var 이름: 타입 = 값`  

>값의 타입이 명확하다면 타입은 생략 가능 하다
>타입 : String, Int, Character ...

    let constant: String = '차후에 변경 불가능한 상수 let'
    var variable: String - '차우헤 변경이 가능한 변수 var'

>상수 선언 후에 나중에 값 할당하기(이 때 무조건 상수나 변수의 타입을 **명시**해줘야한다.)

    >let sum: Int
    >let inputA: Int = 100
    >let inputB: Int = 200
    >sum = inputA + inputB

    >var nickName: String
    >nickName = "Joon"
    >nickName = "준영"

#2 기본 데이터 타입
>Bool, Int, UInt, Float, Double, Character, String

##Bool
    >var someBool: Bool = true
    >someBool = false
    //someBool = 0이나1 넣으면 오류발생

##Int, UInt
###Int
정수 타입으로 기본 64비트

    Var someInt: Int = -100
###UInt
양의 정수 타입으로 기본 64비트

    Var someUInt: UInt = 100


###Float
실수 타입으로 기본 32비트

    >var someFloat: Float = 3.14
    >someFloat = 3

###Double
실수타입으로 기본 64비트

    >var someDouble: =3.14
    >someDouble = 3
    //someDouble = someFloat 하면 컴파일 오류 발생, 같은 타입끼리만 받을 수 있음

##Character, String
###Character
문자타입, 유티코드 사용, 큰따옴표 사용

    >var someCharacter: Character = "K"
    >someCharacter = "준"
    //someCharacter = "gkgkgk" 오류발생

###String
문자열타입, 유니코드 사용, 큰따옴표 사용

    >var somrString: String = "하하하 😄"
    >someString = someString + "웃으면 복이와요"
    하하하 😄 웃으면 복이와요
    //someString = someCharacter 오류발생 같은 타입끼리만 대입할 수 있음

여러줄 문자열은 큰따옴표 3 개 사용

    someString = '''
    여러줄 문자열을 사용할 수 있습니다.
    첫 줄에 겹따옴표 세 개,마지막 줄에 겹따옴표 세 개를
    사용하면 됩니다.
    '''

    someString = '''
    겹따옴표 세 개인 줄(첫줄, 끝줄)에서 줄 바꿈을 하지 않으면 오류가 발생합니다.
    '''
    
    someString = '''오류발생
    오류발생'''

#3 Any, AnyOnject, nil
##Any
Swift의 모든 타입을 지칭하는 키워드

    >var someAny: Any = 100
    >someAny = "어떤 타입도 수용 가능"
    >someAny = 3.14

    //let someDouble: Double = somaAny 하면 컴파일 오류 발생, 같은 타입이 아니라서 불가능

##AnyObject
모든 클래스 타입을 지칭하는 프로토콜   

    Class SomeClass {}
    var someAnyObject: anyObject = SomeClass()

AnyObject는 클래스의 인스턴스만 수용 가능하기 때문에 클래스의 인스턴스가 아니면 할당할 수 없다.

    someAnyObject = 3.14 //오류발생

###nil
>다른 언어의 Null 과 유사하다. 없음을 의미한다.

    someAny = nil //오류발생
    someAnyObject = nil //

#4 콜렉션 타입

##4-1 Array 배열
빈 Int Array 생성

    //모두 같은 표현
      var integers: Array<Int> = Array<Int>()
      var integers: Array<Int> = []
      var integers: [Int] = Array<Int>()
      var integers: [Int] = [Int]()
      var integers: [Int] = []
      var integers = [Int]()

###Array 활용

    integers.append(10) //원소 추가
    integers.contains(10) //포함여부 Bool값으로 반환
    integers[0] = 10 //원소값 교체 또는 초기화
    integers.remove(at: 0) //위치 값 제거
    integers.removeLast() //마지막 원소 제거
    integers.removeAll() //원소 전부 제거
    integers.count //리스트 개수 확인

### 불변 Array

    let immutableArray = [1, 2, 3]
    수정이 불가능한 튜플형태

###Array.count 어레이 길이

    var numbers = [1,2,3,4,5]
    numbers.count // 5

##4-2 딕셔너리

Dictionary는 Key 와 Value의 쌍으로 이루어진 리스트타입

    Key = String, Value = Any인 빈 딕셔너리 생성
    
    var anyDictionary: Dictionary<String, Any> = Dictionary<String, Ant>()
    var anyDictionary: Dictionary<String, Any> = [String: Any]()
    var anyDictionary: Dictionary<String, Any> = [:]
    var anyDictionary: [String: Any] = Dictionary<String, Any>()
    var anyDictionary: [String: Any] = [String: Any]()
    var anyDictionary: [String: Any] = [:]
    var anyDictionary = [String: Any]()

###Dictionary 활용 

    //키에 해당하는 값 할당
    anyDictionary["someKey"] = "Value"
    anyDictionaty["anotherKey"] = 100
    print(anyDictionary)//["someKey": "Value", "anotherKey": 100]


    //키에 해당하는 값 변경
    anyDictionary["someKey"] = "dicitionary"

    //키에 해당하는 값 제거
    anyDictionary.removeValue(forKey: "anotherKey")
    anyDictionary["someKey"] = nil

    //let을 사용하여 Dictionary를 선언하면 불면 Dictionary가 된다.
    let emptyDictionary: [String, Value] = [:]

##4-3 Set 집합
Set은 순서가 없고, 멤버가 유힐한 것을 보장하는 컬렉션 타입

>Set선언과 생성
    
    빈 Int Set 생성
    >var integerSet: Set<Int> = Set<Int>()
    >integerSet.insert(1)
    >integerSet.insert(100)
    >integerSet.insert(99)
    >integerSet.insert(99)
    //[1, 100, 99]

>집합 연산

    let setA: Set<Int> = [1, 2, 3, 4, 5]
    let setB: Set<Int> = [3, 4, 5, 6, 7]

    //합집합
    let union: Set<Int> = setA.union(setB)

    //합집합 오름차순
    let sortedUnion: [Int] = union.sorted()

    //교집합
    let intersection: Set<Int> = setA.intersection(setB)

    //차집합
    let substracting: Set<Int> = setA.substracting

#5 if

>if a {실행문}
   
    a 값이 true일 경우 실행한다.

>if !a {실행문}

    a 값이 false일 경우 실행한다.


    var isDarkMode : Bool = true
    if isDarkMode == true {} // 아래처럼 더 짧게 만들 수 있다
    if isDarkMode {} //isDarkMode가 true라 = true를 쓸 필요 없다


>if 문 다른 방법  
>if = ? , else = :

    var isDarkMode : Bool = true
    var title : String = isDarkMode == true ? "다크모드입니다. : "다크모드가 아닙니다"
    
    //title에 isDarkMode를 대입하고, ture ? 참일때 다크모드입니다 리턴하고, 아닐때 다크노드가 아닙니다 리턴한다.

    
    //위에서 = true를 생략할 수 있다.
    var title : String = isDarkMode ? "다크모드 입니다." : "다크모드가 아닙니다"

#6 for문
>where을 사용해서 if문처럼 걸러준다

    for item in myArray where item % 2 ==0{}

#7 옵셔널

    >var someVariable : Int? = nil

    >if someVariable == nil {
    >  someVariable = 90
    > }
    >print(someVariable)
    Optional(90) // 옵셔널로 쌓여서 나온다.

>언래핑

    >if let otherVariable = someVariable { //let otherVariable의 값이 nill이 아니면 참 
    >  print(otherVariable)
    >}
    90 //if let을 사용하면 옵셔널 값이 강제 언래핑 되어서 나온다

>비어있을 때 넣는 방법

    >someVariable = nil
    >let myValue = someVariable ?? 10
    // someVariable이 비어있으면 10을 넣겠다는 의미

#8 a ?? b Nil-coalscig operator

>어떤 값이 nil일 수도 있는 상황일때 대신 다른 디폴드 값을 주고 싶을때 사용한다.
"""



"""##8-1 a ? b : c삼항연산 또는 조건부 연산
>같은 식으로 아래 처럼 표현할 수 있다.

    a != nil ? a! : b
    a 가 nil이 아니라면 a!(언래핑) 하고 아니라면 b이다

>삼항식을 조건식으로 변환하면  
>간단히 표현하자면 (condition) ? {code for YES} : {code for NO}

    label.frame = (inPseudoEditMode) ? kLabelIndentedRect : kLabelRect

    if(inPseudoEditMode) {
      label.frame = kLabelIndentedRect
    } else {
      label.frame = kLabelRect;
    }

#9 struct 와 class 차이
##struct
    >struct YoutuberStruct {
    >  var name : String
    >  var subscribersCount : Int
    >}

    >var joon = YoutuberStruct(name: "정과장", subscribersCount: 99999) 
    >var joonClone = joon //구조체에 있는 양식을 활용해서 joon 변수에 변경된 구조체를 복사한다.
    >joonclone.name = "호롤롤로"
    >print(joon.name)
    >print(joonClone.name)
    정과장
    호롤롤로 // joonclone은 joon의 복사본 이기 때문에 서로 영향을 미치지 않는다.

##class
    >class YoutuberClass {
    >  var name : String
    >  var subscribersCount : Int
    //init(생성자) - 즉 메모리에 올린다.
    //init으로 매개변수를 가진 생성자 메소드를 만들어야 매개변수를 넣어서 그 값을 가진 객체(object)를 만들 수 있다.
    >  init(name: String, subscribersCount: Int){
    >    self.name = name
    >    self.subscribersCount = subscribersCount
    >    }
    >}

    >var joon = YoutuberClass(name: "정과장", subscribersCount: 99999)
    >var joonClone = joon
    >joonClone.name = "호롤롤로"
    >print(joon.name)
    >print(joonClone.name)
    호롤롤로
    호롤롤로 //class는 객체이기 때문에 복사가 아닌 포인터라 원본이 바뀌면 복사본도 바뀐다.

    나중에 데이터 참조와 복사에 대해서 더 알아보자

#10 eum

???

#11 제네릭<>

>어떤 자료든 받을 수 있음

    struct MyArray<T>{
      var elements : [T] = [T]() //빈 어레이 생성
      //생성자
      init(_ elements: [T]){
        self.elements = elements

#12 클로저

>string을 반환하는 클로저

    let myName: String = { return "정과장" }()

>클로저 정의

    let myRealName: (String) -> String = { (name: String) -> String in return "개발하는 \(name)"
    //myRealName을 실행하면 (String)을 받아서 -> String을 반환한다. 그러면 받은 (String)은 (name: String)을 받아서 -> return 값을 String으로 반환한다. 

>위와 아래 식은 같다, 요약함

    let myRealName = { (name: String) ->  in return "개발하는 \(name)"

>반환값이 없는 클로저

    let myRealNameLogic: (String) -> Void = { (name: String) in print("개발하는 \(name))
    }

클래스는 빵틀이다. 클래스만으로는 아무것도 못한다.

    클래스를 활용해 객체를 만들면 메모리에 올라간다.

    즉 메모리 주소값을 가진다.

#13 map, filter, reduce - stream 문법

##13-1 map

스위프트 라이브러리에서 제공하는 고차함수이다.  
고차함수는 다른 함수를 전달인자로 받서나 함수실행의 결과를 함수로 반환하는 함수다.
>map : 기존 데이터를 변형하여 새로운 컨테이너를 만드는데, 기존 데이터는 변형되지 않는다. for-in 구조를 짧게 만드는 효과가 있다.

*for-in

    let numArray - [1,3,5,7,9]
    var multiArray = [Int]()
    for num in numArray{
      multiArray.append(num*2)
    }
    
*map

    let numArray = [1,3,5,7,9]
    let mulriArray = numArray.map{$0*2}

원래의 코드를 보면

  let multiArray = numArray.map({(number: Int) -> Int in return number*2})

  (number: Int) -> Int 는 생략 가능하다.
  in return 또한 생략 가능하다.
  number은 first인자 이기 때문에 $0으로 바꿀 수 있다.

##13-2 filter

>필터는 기존 컨테이너에서 내부의 값을 걸러 새로운 컨테이너를 만든다.

*for-in

    let stringArray = ["가수", "대통령", "개발자", "선생님", "의사"]
    var threeCountArray = [String]()
    for st in stringArray {
      if st.count == 3{
        threeCountArray.append(st)
      }
    }
    
*filter

    let stringArray = ["가수", "대통령", "개발자", "선생님", "의사"]
    let threeCountArray = stringArray.filter($0.count == 3)

원래 아래와 같은 식을 줄인것임

    let threeCountArray = stringArray.filter({value: String) -> Bool in return value.count == 3
    })

##13-3 reduce

>기존 컨테이너에서 내부의 값들을 결합하여 새로운 값을 만든다.

*for-in

    let numverArray = [1,2,3,4,5,6,7,8,9,10]
    var sum = 0
    for number in numberArray{
      sum += numver
    }
    
*reduce

    let numverArray = [1,2,3,4,5,6,7,8,9,10]
    let sum = numberArray.reduce(0){$0 + $1}

    let sum = numberArray.reduce(0,+) 로도 줄일 수 있음

*원래 아래와 같은 식을 줄인것임

    let sum = numberArray.reduce(0, {(first: Int, second: Int) -> Int in return first + second
    })

>reduce(0) 은 시작값으로 0부터 더한다는 뜻이다.

    예를들어
    numberArray.reduce(2){$0+$1}
    //2+1
    //3+2
    //5+3
    //... 이런식이다.


*reduce함수 원래 식

    func reduce<Result>(
      _ initialResult: Result,
      _ nextPartialResult: (Result, Element) throws -> Result
    ) rethrows -> Result
    //initialResult로 전달된 값은 클로저가 처음 실행될 때 nextPartialResult로 전달됩니다. 그리고 nextPartialResult값과 결합되어서 최종값이 리턴됩니다.
    nextPartialResult에 전달된 값은, initialResult와 함께 계산되서 최종값을 리턴해줍니다.
"""